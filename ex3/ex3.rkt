#lang racket #| CSC324 Fall 2019: Exercise 3 |#
#|
* Before starting, please review the exercise guidelines at
http://www.cs.toronto.edu/~lczhang/324/assignments.html *
|#
;-------------------------------------------------------------------------------
(provide calculate eval-calc)


;-------------------------------------------------------------------------------
; * Task 1 and 2: Using and Building an environment *
;-------------------------------------------------------------------------------

#|
(calculate expr)
  expr: A datum representing an expression generated by the
        Expanded Binary Arithmetic Expression Grammar in the handout

  Calls the function `eval-calc` with an empty environment.
  You do not need to modify this function.
|#
(define (calculate expr)
  (eval-calc expr (hash)))

#|
(eval-calc expr env)
  expr: A datum representing an expression generated by the
        Expanded Binary Arithmetic Expression Grammar in the handout
  env:  A hash table representing an environment.
        The keys of the hash table are symbols representing identifiers.

  You may assume that if an `expr` is an identifier, then it is present in `env`.

  Relevant documentation:
    https://docs.racket-lang.org/reference/hashtables.html
    (look up `hash-ref`, `hash-set`, and `hash`)

  In Racket, the function `hash-set` takes a hash table, a new key-value pair,
  and returns a *new* hash table with all the elements in the old hash table,
  plus the new key-value pair.
|#

(define/match (eval-calc expr env)
  [((? number?) _) expr] ;single number
  [((list '+ b c) _) (+ (eval-calc b env) (eval-calc c env))]
  [((list '- b c) _) (- (eval-calc b env) (eval-calc c env))]
  [((list '* b c) _) (* (eval-calc b env) (eval-calc c env))]
  [((list '/ b c) _) (/ (eval-calc b env) (eval-calc c env))]
  [((? symbol?) _) (hash-ref env expr)] ;single symbol
  [((cons 'let* xs) _) (eval-calc (third expr) (build-env (second expr)))]
  )

(define (build-env bindings)
  (define (build-helper binding hs)
    (if (list? (second binding))
        (hash-set hs (first binding) (hash-ref hs (eval-calc (second binding) hs)
                                               (eval-calc (second binding) hs)))
        (hash-set hs (first binding) (hash-ref hs (second binding) (second binding))))
    )
  (foldl build-helper (hash) bindings) ; (hash) = base
  )



(module+ test
  (require rackunit)

  (test-equal? "Multiple binding {a: 3, b: 4}"
               (calculate '(let* ((a 3) (b 4)) (+ a b)))
               7)
  
  (test-equal? "Recursive bindings"
               (calculate '(let* ((a 3) (a (+ a 1))) (* a 2)))
               8))
(module+ test
  (require rackunit)
    
  ; Task 2 tests
  (test-equal? "Environment lookup {a: 1}"
               (eval-calc 'a (hash 'a 1))
               1)
  (test-equal? "Environment lookup {a: 3}"
               (eval-calc '(+ a 1) (hash 'a 3))
               4)
  (test-equal? "Environment lookup {a: 2, b: 20}"
               (eval-calc '(+ a (* b 2)) (hash 'a 2 'b 20))
               42)
    
    
  ; Task 3 tests
  (test-equal? "Let* binding {a: 3}"
               (calculate '(let* ((a 3)) (+ a 1)))
               4)
  (test-equal? "Multiple binding {a: 3, b: 4}"
               (calculate '(let* ((a 3) (b 4)) (+ a b)))
               7)
  (test-equal? "Recursive bindings"
               (calculate '(let* ((a 3) (a (+ a 1))) (* a 2)))
               8))

