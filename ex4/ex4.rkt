#lang racket #| CSC324 Fall 2020: Exercise 4 |#

;-------------------------------------------------------------------------------
(provide calculate eval-calc)

;-------------------------------------------------------------------------------
; * Task 1: Eager Evaluation *
;-------------------------------------------------------------------------------

#|
(calculate expr)
  expr: A datum representing an expression generated by the
        grammar in the Exericse 4 handout
|#
(define (calculate expr)
  (eval-calc expr (hash)))

#|
(eval-calc expr env)
  expr: A datum representing an expression generated by the
        grammar in the Exercise 4 handout
  env:  A hash table representing an environment.
        The keys of the hash table are symbols representing identifiers.

  You may assume that if an `expr` is an identifier, then it is present in `env`.
|#
(define/match (eval-calc expr env)
  
  [((cons x xs) 1) (list x)]
  [((? number?) _) expr] ;single number
  [((list '+ b c) _) (+ (eval-calc b env) (eval-calc c env))]
  [((list '- b c) _) (- (eval-calc b env) (eval-calc c env))]
  [((list '* b c) _) (* (eval-calc b env) (eval-calc c env))]
  [((list '/ b c) _) (/ (eval-calc b env) (eval-calc c env))]
  [((? symbol?) _) (hash-ref env expr)] ;single symbol
  [((cons 'let* xs) _) (eval-calc (third expr) (build-env (second expr)))]

  ; with argument
  [((cons (list 'lambda id body) arg) env) (eval-calc body (arg-helper id arg env))]

  ; without argument
  [((list 'lambda id body) _) (env-hash-helper expr env id)]
  )


(define (env-hash-helper expr env id)
  (if (hash-has-key? env (car id))
      (eval-calc (last expr) env)
      (list 'closure expr env)))
 

(define/match (arg-helper keys values env)
  [((list) (list) env) env]
  [((cons key keys) (cons val vals) env) (arg-helper keys vals (hash-set env key val))])


(define (helper lst1 lst2 acchash)
  (if(empty? lst1)
     acchash
     (helper (rest lst1) (rest lst2) (hash-set acchash (first lst1) (hash-ref acchash (first lst2) (first lst2)))))
  ) 


(define (build-env bindings)
  (define (build-helper binding hs)
    (if (list? (second binding))
        (hash-set hs (first binding) (hash-ref hs (eval-calc (second binding) hs)
                                               (eval-calc (second binding) hs)))
        (hash-set hs (first binding) (hash-ref hs (second binding) (second binding))))
    )
  (foldl build-helper (hash) bindings) ; (hash) = base
  )


(module+ test
  (require rackunit)

  (test-equal? "No parameters, arg already defined"
               (eval-calc '(lambda (b) (+ b 1)) (hash 'b 12))
               13)

  (test-equal? "try2"
               (calculate '(lambda (c) (+ c 1)))
               '(closure (lambda (c) (+ c 1)) #hash()))
  
  (test-equal? "Closure only"
               (calculate '(lambda (x) (+ x 1)))
               '(closure (lambda (x) (+ x 1)) #hash()))
 

  (test-equal? "multiple lambda"
               (calculate '((lambda (b) (lambda (c) (+ c 1)) ) 4))
               '(closure (lambda (c) (+ c 1))  #hash((b . 4)))))


