#lang racket #| CSC324 Fall 2020: Exercise 2 |#
#|

|#
;-------------------------------------------------------------------------------
; This expression exports functions so they can be imported into other files.
; Don't change it!
(provide apply-fns make-counter apply-fns sum-map-both sum-map-both-helper calculate)

(module+ test
  ; Import the testing library
  (require rackunit))

;-------------------------------------------------------------------------------
; * Task 1: num-pred *
;-------------------------------------------------------------------------------

#|
(num-pred pred lst)
  pred: A function that takes one argument and returns a boolean
  lst: A list of items.

  Returns the number of items in the lst for which (pred item) returns True
|#
(define (num-pred pred lst)
  (cond
    [(null? lst) 0]
    [else
     (let ([first-number (first lst)] [rest-number (num-pred pred (rest lst))])
       (cond
         [(pred first-number) (+ rest-number 1)]
         [else rest-number]
         )
       ) 
     ]
    )
  )


;-------------------------------------------------------------------------------
; * Task 2: More Higher-Order Functions * 
;-------------------------------------------------------------------------------

#|
(make-counter pred)
  pred: A function that takes one argument and returns a boolean

  Returns a function that takes a list and returns the number of elements
  in the list satisfying that predicate.
|#

(define (make-counter pred)
  (lambda (lst) (num-pred pred lst)))

; Uncomment and define these using `make-counter`.
(define num-evens-1
  (make-counter even?))

(define num-many-evens-1
  (make-counter num-evens-1))

(module+ test
  ; TODO: write your own tests to make sure make-counter is implemented correctly.
  (test-equal? "make-counter check even with many elements"
               ((make-counter even?) '(1 2 4 5))
               2)

  (test-equal? "make-counter check even with many elements"
               (num-pred even? '(1 2 4 5))
               2)
  
  )


#|
(apply-fns fns arg)
  fns: A list of unary functions.
  arg: A value.

  Returns a list of the results of applying each function in `fns` to `arg`.
|#
(define (apply-fns fns arg)
  
  (cond
    [(null? fns) '()]
    [else (cons ((first fns) arg)
                (apply-fns (rest fns) arg))
          ]
    )
  )


(module+ test

  (test-equal? "(apply-fns (list integer?) 4)"  ; Test label
               (apply-fns (list integer?) 4)   ; Actual value
               (list #t))      

  
  (test-equal? "(apply-fns (list integer? null?) 4)"  ; Test label
               (apply-fns (list integer? null?) 4)   ; Actual value
               (list #t #f))                         ; Expected value
  ; TODO: write more tests
  )

#|
(sum-map-both fn lst1 lst2)
  fn: A function that takes two arguments and returns a number.
  lst1: A list
  lst2: Another list of equal length

  Precondition: (equal? (length lst1) (length lst2))
  You do not need to check the pre-condition. We will only be testing
  with tests that satisfy the pre-condition.

  Returns the sum of the `fn` applied to each of the pairs of values
  in lst1 and lst2. We would like this function to be *tail-recursive*,
  so it should call the helper function `sum-map-both-helper` with
  an appropriate initial accumulator value.
|#
(define (sum-map-both fn lst1 lst2)
  (sum-map-both-helper fn lst1 lst2 0))
; (sum-map-both-helper fn lst1 lst2 TODO))


#|
(sum-map-both-helper fn lst1 lst2 acc)
  fn: A function that takes 
  lst1: A list
  lst2: Another list of equal length
  acc: A number describing the accumulated values so far

  Precondition: (equal? (length lst1) (length lst2))
  You do not need to check the pre-condition. We will only be testing
  with tests that satisfy the pre-condition.

  Helper function for sum-map-both-helper. We *will* be testing this
  helper function.
|#
(define (sum-map-both-helper fn lst1 lst2 acc)
  (if(empty? lst1)
     acc
     (sum-map-both-helper fn (rest lst1) (rest lst2) (+ (fn (first lst1) (first lst2)) acc)))
  ) 

#;(module+ test
    (test-equal? "(sum-map-both - '(5 10 7) '(2 6 5))" ; Test label
                 (sum-map-both - '(5 10 7) '(2 6 5))   ; Actual value
                 9)  ; Expected value = (5 - 2) + (10 - 6) + (7 - 5)
    ; TODO: write more tests

    (test-equal? "(sum-map-both + '(5 10 7) '(2 6 5))" ; Test label
                 (sum-map-both + '(5 10 7) '(2 6 5))   ; Actual value
                 35)
    
    )

;-------------------------------------------------------------------------------
; * Task 4: Calculator *
;-------------------------------------------------------------------------------

#|
(calculate expr)
  expr: An expression generated by the Binary Arithmetic Expression Grammar
        described in the handout.

  Return the numerical value of the expression
|#
(define/match (calculate expr)

  [((? number?)) expr] 
  [((list '+ b c)) (+ (calculate b) (calculate c))]
  [((list '- b c)) (- (calculate b) (calculate c))]
  [((list '* b c)) (* (calculate b) (calculate c))]
  [((list '/ b c)) (/ (calculate b) (calculate c))]
  )
  

(module+ test
  (require rackunit)
  (test-equal? "calculate: +"
               (calculate '(+ 2 3)) ;'(+ 2 3) is the same as (list '+ 2 3)
               5)
  
  (test-equal? "calculate: /"
               (calculate '(/ (+ 2 6) 2))
               4)

  (test-equal? "calculate: *"
               (calculate (* (- 2 6) 2))
               -8)
  )

(module+ test
  (test-equal? "apply-funs with integer and 2 functions" 
               (apply-fns (list integer? null? ) 4)   
               (list #t #f))                        
  (test-equal? "apply-funs with a non-empty list and 3 functions" 
               (apply-fns (list list? integer? number?) '(1 2 3 4 5))   
               (list #t #f #f))
  (test-equal? "apply-funs with an interger with 5 functions" 
               (apply-fns (list list? integer? number? odd? even?) 2)   
               (list #f #t #t #f #t))
  (test-equal? "apply-funs with an interger with no functions" 
               (apply-fns (list ) 2)   
               (list ))
  (test-equal? "apply-funs with an emty list with 1 function" 
               (apply-fns (list null?) '())   
               (list #t))
  (test-equal? "apply-funs with a string with 2 functions" 
               (apply-fns (list string? list?) "Ryan")   
               (list #t #f))
  (test-equal? "apply-funs with a function with 3 functions (lambda)" 
               (apply-fns (list (lambda (f) (f 3))
                                (lambda (f) (f 4))
                                (lambda (f) (f 5)))(lambda (x) (* 3 x)))   
               (list 9 12 15))
  )
(module+ test
  (test-equal? "sum-map-both subtraction with two lists"
               (sum-map-both - '(5 10 7) '(2 6 5))   
               9) 
  (test-equal? "sum-map-both multiplication with two lists" 
               (sum-map-both * '(1) '(2))   
               2)
  (test-equal? "sum-map-both multiplication with two empty lists" 
               (sum-map-both - '() '())   
               0)
  (test-equal? "sum-map-both advanced doubling with two lists" 
               (sum-map-both (lambda (x y) (* 2 ( + x y))) '(1 2 3) '(4 5 6))   
               42)
  (test-equal? "sum-map-both halving  with two lists" 
               (sum-map-both (lambda (x y) (/ 2 ( + x y))) '(1 1) '(1 1))   
               2)
  (test-equal? "sum-map-both halving  with two lists" 
               (sum-map-both (lambda (x y) (/ 2 ( + x y))) '(1 1) '(1 1))   
               2)
  (test-equal? "sum-map-both-helper adding with two lists, starting at 2" 
               (sum-map-both-helper + '(1 1) '(1 1) 2)   
               6) 
  )

(module+ test
  (require rackunit)

  (test-equal? "calculate NUM"
               (calculate 5)
               5)
  (test-equal? "calculate *"
               (calculate '(* 2 3))
               6)
  (test-equal? "calculate / with nested +"
               (calculate '(/ (+ 2 6) 2))
               4)
  (test-equal? "calculate / with nested + and -"
               (calculate '(/ (+ 2 (- 6 2)) 2))
               3)
  (test-equal? "calculate with ALL operations (+ | - | * | / )"
               (calculate '(+ (- 2 (/ 4 2)) (* 3 4)))
               12)
  )